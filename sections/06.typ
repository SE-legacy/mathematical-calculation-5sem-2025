#set math.equation(numbering: "1.")
// NOTE: Лекция 6. 07.10.2025

== Параграф 2 (Дополнения к методу Гаусса).
=== Процедура выбора главного (ненулевого) элемента.
В предыдущем параграфе мы рассмотрели базовую конструкцию метода Гаусса, в
рамках которой на прямом ходе мы попутно делали предположения, что $a_(1 1)
eq.not 0$ и в результате мы могли делить строку на $a_(1 1)$ и что 
$a_(2 2)^((1)) eq.not 0;$ с такой же целью и $a_(3 3)^((2)) eq.not 0; space dots
space a_(n n)^((n - 1)) eq.not 0$.

Соответственно, если на $k$-ом шаге прямого хода мы встретим $a_(k k)^((k - 1)) 
eq.triple 0; space (a_(k k)^((k - 1)) in O_delta = (-delta, delta))$,

$mat(
	1, dots, dots, dots, dots, dots;
	0, 1, dots, dots, dots, dots;
	0, 0, dots, a_(k k)^((k - 1)), dots, dots;
	0, 0, dots, a_(m k)^((k - 1)), dots, dots;
	dots, dots, dots, dots, dots, dots;
	augment: #5
)
$

В этом случае в строка с $k + 1, dots, n$ ищут элемент 
$
	#[(\*)] quad a_(n k)^((k - 1)) = limits(max)_(k + 1 lt.eq j lt.eq n) |a_(j k)|
$<l6:eq1>

+ Если $a_(m k)^((k - 1)) eq.not 0 space (in.not (- delta, delta))$, то меняют
	местами $k$-ую и $m$-ую *строки* РМК. В этом случае в позиции $(k; k)$ 
	$a_(m k)^((k - 1)) eq.not 0 space (in (- delta, delta))$,
	и прямой ход метода Гаусса может быть продолжен. Т.е. нормировка строки будет
	возможна.
+ Если $a_(m k)^((k - 1)) eq 0 space (in (- delta, delta))$, тогда перестановка
	строк не решает проблему. И в этом случае ищет элемент 
	$ 
		#[(\*\*)] quad a_(k m)^((k - 1)) = limits(max)_(k + 1 lt.eq j lt.eq n) |a_(k j)|
	$<l6:eq2>
	и в этом случае, если 
	$a_(k m)^((k - 1)) eq.not 0 space (in.not (- delta, delta))$, то меняют $k$-й
	и $m$-й *столбец*

Таким образом, если элементы определенный по формулам @l6:eq1 и @l6:eq2 будут
равны $0$, то прямой ход метода Гаусса будет вынуждено преостановлен ввиду
невозможности произвисти нормировку сответствующего диагонального элемента

В случае перестановки столбцов в РМК параллельно необъодимо запоминать 
соответствующую перестановку в вектор $x$ с тм чтобы после завершения уже после
обратного хода выполнить обратную перестановку незивестных вернув им натуральный
порядок нумерации

=== Нахождение определителя квадратной матрицы $A_(n times n)$

$
A = mat(
	a_(1 1), a_(1 2);
	a_(2 1), a_(2 2);
)_(2 times 2) -> Delta = a_(1 1) a_(2 2) - a_(1 2) a_(2 2)
$

$
A = mat(
	a_(1 1), a_(1 2), a_(1 3);
	a_(2 1), a_(2 2), a_(2 3);
	a_(3 1), a_(3 2), a_(3 3);
)_(2 times 2) -> Delta =  a_(1 1) a_(2 2) a_(3 3) + a_(2 1) a_(3 2) a_(1 3) +\
+ a_(1 2) a_(2 3) a_(3 1) - a_(1 3) a_(2 2) a_(3 1) - a_(2 1) a_(1 2) a_(3 3) 
- a_(3 2) a_(2 3) a_(1 1)
$

$
A_(n times n) -> Delta ~ n!
$

Таким образом с ростом размерности матрицы  $n$ число опреаций необходимо для 
назождения определителя этой матриц по классической формуле нахождения
определителя растет довольно заметно. 

Применим к матрице $A_(n times n)$ процедуру диагонализации позаимствованной из
метода Гаусса

$
A_(n times n) mat(
	a_(1 1), dots, a_(1 n);
	dots, dots, dots;
	a_(n 1), dots, a_(n n);
) ~  ->^(#[эквив. преобр.\ над матриц.]) dots ~ mat(
	1, , , , ;
	 ,1, , overline(a)_(i j), ;
	 ,0, dots , , ;
	 , , , dots , ;
	 , , , , 1;
)
$

Приэтом вспомним, что в процедуре диагонализация матрицы применяется следующие
эквивалентные преобразования:
+ $#[стр] times 1/(a_(k k)^((k - 1))$
+ $#[стр] + #[стр] times underbrace(lambda, eq.not 0)$
+ Меняются местами строки или столбцы (в процедуре выбора главного элемента)

// TODO: У Темы и Сани есть

Таким образом после завершения процедуры диагонализации исходной матрицы $A$
исходный ее определитель будет подвергнут следующим преобразованиям

$
Delta / (a_(1 1) dot a_(2 2)^((1)) dot a_(3 3)^((2)) dot dots dot a_(n n)^((n - 1)))
= (- 1)^nu dot underbrace(limits(Delta)^~, = 1)\
$
$
#[(1)] quad Delta = (- 1)^nu dot a_(1 1) dot a_(2 2)^((1)) dot a_(3 3)^((2)) dot dots dot a_(n n)^((n - 1))
$<l6:eq3>
где $nu$ --- количество реализованных ПВГЭ

*Замечание* Отметим, что для того чтобы воспользоваться формулой @l6:eq3, необходимо
узнать нормирующие коэффициенты $a_(2 2)^((1)), a_(3 3)^((2)), dots, a_(n n)^((n - 1))$
для чего необходимо реализовать процедуру диагонализации матрицы в полном объеме
