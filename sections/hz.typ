(30.09)
= Метод Гаусса

$ cases(
  a_11 x_1 + a_12 x_2 + dots + a_(1 n) x_n = b_1,
  a_21 x_1 + a_22 x_2 + dots + a_(2 n) x_n = b_2,
  dots,
  a_(n 1) x_1 + a_(n 2) x_2 + dots + a_(n n) x_n = b_n
) <=> A = mat(
  a_11, dots, a_(1 n);
  dots.v;
  a_(n 1), dots, a_(n n)
)_(n crossmark n), b = mat(b_1; b_2; dots.v; b_n), x = mat(x_1; dots.v; x_n) - ? $ <l5:eq1>

$ <=> "Р. М. К. (СЛАУ 1):" mat(
  a_11, dots, a_(1 n), b_1;
  a_21, dots, a_(2 n), b_2;
  dots.v;
  a_(n 1), dots, a_(n n), b_n; augment: #3) = (A | B) $

Далее будем предполагать, что СЛАУ 1, размерности $n crossmark n$ имеет единственное решение. Метод Гаусса условно подразделяют на два последовательных этапа: прямой и обратный ход. Рассмотрим их подробнее.

+ Прямой ход М. Г.:
   Сутью прямого хода является преобразование Р.М.К. системы 1 к так называемому верхнему треугольному виду.

   Далее, над РМК будем проводить следующие эквивалентные операции, сохраняющие решение системы:

   $ mat(
    a_11, dots, a_(1 n), b_1;
    a_21, dots, a_(2 n), b_2;
    dots.v;
    a_(n 1), dots, a_(n n), b_n; augment: #3) 
    limits(~)
    ^("1 стр" crossmark 1/a_11, a_11 != 0)
    _("2 стр" - "новую" 1"-ю" crossmark a_21) 
    mat(
      1, a_12^((1)), dots, a_(1 n)^((1)), b_1^((1));
      0, a_22^((1)), dots, a_(2 n)^((1)), b_2^((1));
      0, a_32^((1)), dots, a_(3 n)^((1)), b_3^((1));
      dots;
      0, a_(n 2)^((1)), dots, a_(n n)^((1)), b_n^((1));
      augment: #4
    ) \
    limits(~)
    ^("2 стр" crossmark 1/a_22^((1)), a_22 != 0)
    _("3 стр" - "нов. 2-я строка" crossmark a_32^((1)))
    mat(
      1, a_12^((1)), dots, 
    )
   $

  (объяснение алгоритма: \
  3 строка МИНУС новая 2-я строка $crossmark a_32^((1))$\
  4 строка МИНУС новая 2-я строка $crossmark a_42^((1))$\
  ... \
  n-ная строка МИНУС новая 2-я строка $crossmark a_(n 2)^((1))$)

  По итогу получим:
  $ mat(
    1, a_12^((1)), a_13^((1)), dots, a_(1 n)^((1)), b_1^((1));
    0, 1, a_23^((2)), dots, a_(2 n)^((2)), b_2^((2));
    0, 0, a_33^((1)), dots, a_(3 n)^((1)), b_3^((2));
    dots;
    0, 0, a_(n 3)^((2)), dots, a_(n n)^((1)), b_n^((n));
    augment: #5
  ) $

  Продолжаем аналогичные операции, а именно, выполняя нормировку следующего диагонального элемента, и, обнуляя элементы, стоящие ниже него (построчно), за конечное число шагов мы придём к РМК следующего вида:

  $ mat(
    1, a_12^((1)), a_13^((1)), a_14^((1)), dots, a_(1, n-1)^((1)), a_(1 n)^((1)), b_1^((1));
    0, 1, a_23^((2)), a_24^((2)), dots, a_(2, n-1)^((2)), a_(2 n)^((2)), b_2^((2));
    0, 0, 1, a_34^((3)), dots, a_(3, n-1)^((3)), a_(3 n)^((3)), b_3^((3));
    dots;
    0, 0, 0, 0, dots, 1, a_(n-1, n)^((n-1)), b_(n-1)^((n-1));
    0, 0, 0, 0, dots, 0, 1, b_n^((n));
    augment: #7 
  ) $ <l5:eq2>

  После того, как нормировка завершена, получен финальный вид РМК.

+ Обратный ход М. Г. \
  Из n-ной строки Р. М. К /*@l5:eq2*/ 
  $=> 0 dot x_1 + 0 dot x_2 + dots + 0 dot x_(n - 1) + 1 dot x_n = b_n^((n)) -> x_n = b_n^((n))$ \
  Из n-1-ой строки $=> 0 dot x_1 + 0 dot x_2 + dots + 1 dot x_(n - 1) + a_(n-1, n)^((n-1)) dot x_n = b_(n-1)^((n-1)) -> x_(n-1) = b_(n-1)^((n-1)) - a_(n - 1)^((n - 1)) dot x_n$\
  $dots$\
  Из 1-й строки $=> x_1 = b_1^((1)) - limits(sum)_(k=2)^n a_(1, k)^((1)) x_k$

  Замечание: Всё время мы считали, что $a_(i, j) != 0, forall i=j$. В этом случае алгоритм будем называть Базовой версией метода Гаусса (БВМГ). Если же хоть один элемент равен нулю, то прибегнем к Процедуре выбора главного элемента (ПВГЭ)