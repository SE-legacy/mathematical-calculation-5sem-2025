#set math.equation(numbering: "1.")

= Пролог

#underline[*Поплавский Дмитрий Владиславович.*]

Вычислительная математика или математика вычислений. Одна тетрадь для лекций, другая черновая.

= Интерполяция функции одного аргумента
== Постановка задачи интерполяции
_Interpolate (с англ.)_ --- "приближать".

Пусть задана дискретным набором своих значений некоторая функция $f$, а именно данная функция определена следующей таблицей своих значений:

#align(center, 
  table(
    columns: 4,
    [x_0], [x_1], [...], [x_n],
    [f_0], [f_1], [...], [f_n)]
  )
)
где $f_k = f(x_k), space forall k = overline("0, n")$

Требуется указать (построить) непрерывную на некоторой области функцию $g(x)$ такую, чтобы выполнялись следующие условия:
$ g(x_k) = f_k, space forall k = overline("0, n") $<l1:eq1>

#image("imgs/1.png")

Мы будем строить функцию, которая совпадает с заданной во всех узловых точках. По ней мы будем предполагать значения в точках, находящихся между узлами.

\ Точки $x_0, x_1, ..., x_n$ будем называть *узлами интерполяции* (приближения)
\ Функция $f$, заданная набором значений $(x_k, f_k) space forall n = overline("0, n")$, называется *интерполируемой* (приближаемой).
\ Функцию $g(x)$, удовлетворяющей условиям @l1:eq1 будем называть *интерполирующей* (интерполяционной, приближающей) или же *"интерполянта"*
\ Условия @l1:eq1 будем называть *Главным Условием Интерполяции (ГУИ)*

_Замечание:_ в сформулированной постановке задачи интерполяции очевидно в качестве искомой интерполянты можно указать #underline[бесконечное число] непрерывных функций

#image("imgs/2.png")

== Интерполяционный многочлен в общем виде
В этом параграфе покажем, что в качестве искомой интерполянты в *Задаче Интерполяции (ЗИ)* может быть предложен алгебраический многочлен степени $n$, построенный по $n + 1$ попарно различному узлу интерполяции.

Таким образом для $n + 1$ узла интерполяции $x_0, x_1, ..., x_n$ попробуем построить алгебраический многочлен 
$ p_n (x) = underbracket(a_n, ?) x^n + underbracket(a_(n - 1), ?) x^(n - 1) + ... + underbracket(a_1, ?) x + underbracket(a_0, ?) $ <l1:eq2>

Потребуем, чтобы алгебраический многочлен вида @l1:eq2 удовлетворял ГУИ, а именно, чтобы выполнялись следующие равенства:

$ cases(
p_n (x_0) = f_0, 
p_n (x_1) = f_1, 
..., 
p_n (x_n) = f_n
) space limits("<=>")^((2)) space 

cases(
  a_n x_0 ^ n + a_(n - 1) x_0 ^ (n - 1) + ... + a_1 x_0 + a_0 = f_0,
  a_n x_1 ^ n + a_(n - 1) x_1 ^ (n - 1) + ... + a_1 x_1 + a_0 = f_1,
  ...,
  a_n x_n ^ n + a_(n - 1) x_n ^ (n - 1) + ... + a_1 x_n + a_0 = f_n 
) $ <l1:eq3>

Равенство @l1:eq3 по своей алгебраической природе представляют собой СЛАУ (систему линейных алгебраических уравнений) размерности $(n + 1) crossmark (n + 1)$ относительно неизвестных коэфициентов интерполянты $p_n (x) space a_0, a_1, ..., a_n$

Чтобы решить СЛАУ @l1:eq3 необходимо, чтобы её главный определитель был отличен от нуля. Запишем этот определитель $ Delta_((3)) = 
mat(
  x_0 ^ n, x_0 ^ (n - 1), dots.h, x_0, 1;
  x_1 ^ n,  x_1 ^ (n - 1), dots.h, x_1, 1; 
  dots.v, dots.v, dots.down, dots.v, 1;
  x_n ^ n, x_n ^ (n - 1), dots.h, x_n, 1;
) = underbracket("...", "надо считать") = limits(inter.sq.big)_(j > i) (x_j - x_i) underbracket(!=, "чтобы СЛАУ (3) имела ед. реш.") 0 $ <l1:eq4>

Чтобы определитель @l1:eq4 отличался от нуля необходимо, чтобы 
$ x_j != x_i, "если" j != i $ <l1_eq5>

Условие @l1_eq5 называется условием #underline[попарной] различности узлов интерполяции.

Таким образом из вышеизложенного можем получить следующее: При условии @l1_eq5 определитель @l1:eq4 будет отличен от нуля, а следовательно СЛАУ @l1:eq3 будеи иметь единственное решение. Соответственно, решив СЛАУ @l1:eq3 #underline[каким-либо] подходящим численным методом, мы сможем найти её единственное решение, а именно значение искомых коэфициентов $a_0, a_1, ..., a_n$. Подставив их в искомое представление @l1:eq2 мы получим явную аналитическую форму для искомой интерполянты: 
$ p_n (x) = a_n x^n + a_(n - 1) x^(n-1) + ... + a_1 x + a_0 $