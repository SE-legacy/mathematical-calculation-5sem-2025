// NOTE: Лекция 8. 28.10.2025
#set math.equation(numbering: "1.")
== Параграф 4. (Метод простой итерации. Решение СЛАУ)
Попрежнему решаем СЛАУ общего вида
$
#[(1)] A x = b
$<l8:eq1>

Предполагая, что у данной системы существует единственное решение

Покажем, что СЛАУ вид @l8:eq1 может быть преобразована к следующему 
эквивалентному виду

$
x = alpha dot x + beta
$<l8:eq2>

Одним из способов преобразования СЛАУ вида @l8:eq1 к @l8:eq2 может быть следующий

В каждом уравнении системы @l8:eq1 в левой части равенства оставляем ту компоненту
вектора $x$, что имеет номер текущего уравнения. А именно, каждое уравнение 
записываем в виде:

$
#[(1')] quad x_i = 1/(a_(i i)) (b_i - limits(sum)_(j = 1)^(i - 1) a_(i j) x_j 
	- limits(sum)_(j = 1)^(n) a_(i j) x_j), quad i = overline(1\, n)
$<l8:eq1_strix>

Перепишем систему @l8:eq1_strix в матричном виде 

$
mat(x_1; x_2; ... ; x_n) = underbrace(mat(
	0, -(a_(1 2))/(a_(1 1)), -(a_(1 3))/(a_(1 1)), dots , -(a_(1 n))/(a_(1 1));
	-(a_(2 1))/(a_(2 2)), 0, -(a_(2 3))/(a_(2 2)), dots , -(a_(2 n))/(a_(2 2));
	dots, dots, dots, dots, dots;
	-(a_(n 1))/(a_(n n)), -(a_(n 2))/(a_(n n)), -(a_(n 3))/(a_(n n)), dots , a_(n n)
), alpha) dot underbrace(mat(x_1; x_2; ... ; x_n), x) 
	+ underbrace(mat(b_1; b_2; ... ; b_n), beta)
$<l8:eq2_strix>


Таким образом развернутая системы в виде @l8:eq2_strix показвыает, что СЛАУ 
@l8:eq1 может быть преобразована к эквивалентному виду @l8:eq2
Другими словами @l8:eq1 --- это тоже самое, что решить СЛАУ @l8:eq1_strix.

Метод простой итерации (МПИ) решения СЛАУ @l8:eq2 основан на итерационном
(рекурсивном, повторяющемся) построении последовательности векторов

$
{x^((k))}_(k = 0)^infinity
$

По следующей формуле *(Формула МПИ)*:

$
#[(3)] quad {x^((k))}_(k = 0)^infinity : x^((k + 1)) = alpha dot x^((k)) + beta #[, где]
	space x^((0)) #[--- задан некоторым образом]
$<l8:eq3>
// NOTE: я ща усну нахуй

// FIX: рисунок 1 (у Роба есть)
Предположим, что есть вектор $x^((0))$, и вектор $x^((*))$ являющийся // TODO:

Строим вектора $x^((1)), x^((2)), dots x^((k)), x^((k + 1))$ и они сгущаются около
вектора $x^((*))$

Разница $x^((*))$ и $x^((0))$ равна $epsilon^((0))$

Разница $x^((*))$ и $x^((1))$ равна $epsilon^((1))$ и тд по индукции

Выясним, при каких условиях последовтаельность векторов ${x^((k))}^infinity_(k = 0)$
будет сходится к точному решению $x^((*))$ системы @l8:eq2. При этом значение
начального вектора $x^((0))$ будем считать заданным, но пока неизвестным для
себя образом.

Так как $x^((*))$ есть точное решение СЛАУ @l8:eq2, то имеет место следущее тождество:

$
#[(4)] quad x^((*)) = alpha dot x^((*)) + beta
$<l8:eq4>

Составим разность равенств @l8:eq4 и @l8:eq3 при некотором фиксированном $k$

$
#[(5)] quad underbrace(x^((*)) - x^((k + 1)), epsilon^((k + 1))) 
	= alpha dot underbrace((x^((*)) - x^((k))), epsilon^((k)))
	<=> epsilon^((k + 1)) = alpha dot epsilon^((k)) quad forall k = overline(0\, infinity)
$<l8:eq5>

Используя представление @l8:eq5 получим:

$
#[(6)]
cases(
	quad epsilon^((1)) = alpha dot epsilon^((0)),
	epsilon^((2)) = alpha dot epsilon^((1)) = alpha dot alpha dot epsilon^((0)) = alpha^2 dot epsilon^((0)),
	epsilon^((3)) = alpha dot epsilon^((2)) = alpha dot alpha^2 dot epsilon^((0)) = alpha^3 dot epsilon^((0)),
	dots,
	epsilon^((k + 1)) = alpha dot epsilon^((k)) = alpha dot alpha^(k) dot epsilon^((0)) = alpha^(k + 1) dot epsilon^((0))
)
forall k = overline(0\, infinity)
$<l8:eq6>


Таким образом мы имеем последовательность векторов --- погрешностей ${epsilon^((k))}^infinity_(k = 0)$
определяем их по формуле @l8:eq6 или @l8:eq5.


$
rho (x, y) = ||y - x|| #[--- норма]
$

Согласно "известному факту" для того, чтобы последовательность векторов сходилась
к предельному вектору, неообходимо чтобы последовательность норм этих векторов
сходилась к соответствущей норме предельного вектора. В этой связи в векторном
равенстве @l8:eq6 перейдем к соответствующему равенству норм.

$
||epsilon^((k + 1))|| = ||underbrace(alpha^(k + 1), in R^(n times n)) dot epsilon^((0))||

$

$
& ||e^((k + 1))|| \ & = ||limits(underbrace(alpha^(k + 1)))_(in space RR^(n times n) \ ||dot||_(RR^(n times n))) limits(underbrace(epsilon^((0))))_(in space RR^(n) \ ||dot||_(RR^(n)))|| \ & lt.eq.slant ||alpha^(k + 1)||_(RR^(n times n)) dot ||epsilon^(0)||_(RR^(n)) \ & = ||alpha^(k + 1)_(RR^(n times n)) dot ||epsilon^(0)||_(RR^(n)) 

#[--- условие согласованности норм]
$


Из последней цепочки равенств/неравенств получаем:
$
#[(7)] quad ||epsilon^((k + 1))|| = ||alpha||^((k + 1)) dot ||epsilon^((0))||
quad forall k = overline(0\, infinity)
$<l8:eq7>

выполняется при условии согласованности норм


// TODO: 

Следовательно, последовательность векторов ${epsilon^((k + 1))}^infinity_(k = 0)$
будет стремится к $0_(RR^(n))$. Другими словами, последовательность векторов
${x^((*)) - x^((k + 1))}^infinity_(k = 0) -> 0_(RR^(n)) <=> {x^((k + 1))} = x^((*)) or {x^((*))} -> x^((k + 1))$

Таким образом из выше изложенного получаем:

Чтобы последовательность векторов ${x^((k))}^infinity_(k = 0)$ вычисляемых по 
итерационной формуле @l8:eq3 сходилась к точному решению СЛАУ @l8:eq2 --- $x^((*))$
необходимо 
+ наличие с... $ ||dot||_(RR^(n))  ||dot||_(RR^(n times n)) $
+ // TODO: 

*Замечание 1:*

Пример согласованных норм:
- $|| x || = max_(1 lt.eq i lt.eq n) |x_i|$, где $x = mat(x_1; x_2; ... ; x_n) in RR^(n times n)$
- $|| alpha || = max_(1 lt.eq i lt.eq n) limits(sum)_(j = 1)^(n) |alpha_(i j)|$,
	где $alpha = mat(alpha_(1 1), dots, dots, alpha_(n 1); dots, dots, dots, dots; alpha_(n 1), dots, dots, alpha_(n n))$

*Замечание 2:*

При выполнении условия согласованности норм получаем и условие согласованности // TODO: @l8:eq8
$x^((0))$ может быть выбрана любой, но // TODO:

